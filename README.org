#+TITLE: Hammy.el

#+HTML: <img src="images/mascot.png" align="right">

Hammy provides programmable, interactive interval timers for Emacs.  They can be used, e.g. to alternate between working and resting periods, to remind yourself to stretch your legs, etc.  Timers, known as "hammys", are easily defined by the user to behave as desired, and they can be integrated into other programs by calling Lisp functions in the hammys' definitions.

* Installation
:PROPERTIES:
:ID:       f9d7bc00-8bd4-4653-b69e-fdbb1663f5cd
:END:

Until Hammy reaches a package repository, the easiest way to install it is to use [[https://github.com/quelpa/quelpa-use-package][quelpa-use-package]], like this:

#+BEGIN_SRC elisp
  (use-package hammy
    :quelpa (hammy :fetcher github :repo "alphapapa/hammy.el"))
#+END_SRC

* Usage
:PROPERTIES:
:ID:       fae3cf22-c6d7-4d60-95b7-f3d30941959f
:END:

First, define a hammy timer (two are included by default, including the one in the following example) using the domain-specific language Hammy offers for this purpose.  For example, this one reminds you to stand up every so often (e.g. to prevent RSI):

#+begin_src elisp
  (hammy-define "Move"
    :documentation "Don't forget to stretch your legs."
    :intervals
    ;; A list of intervals, each defined with the `interval' function.
    (list (interval
           ;; The name of the interval is a string, used when selecting
           ;; hammys and shown in the mode line.
           :name "ðŸ’º"
           ;; The duration of the interval in seconds (here,
           ;; using the `duration' helper function, which
           ;; converts a string duration to a number of
           ;; seconds).
           :duration (duration "45 minutes")
           ;; Optionally, a face in which to show the
           ;; interval's name in the mode line.
           :face 'font-lock-type-face
           ;; A list of actions to take before starting the interval
           ;; (here, using two built-in helper functions).
           :before (list (announce "Whew!")
                         (notify "Whew!"))
           ;; We want this interval to not automatically advance to the
           ;; next one; rather, we want the user to call the
           ;; `hammy-next' command to indicate when the standing-up is
           ;; actually happening.  So we provide a list of actions to
           ;; take when it's time to advance to the next interval, here
           ;; using three built-in helper functions (including the
           ;; built-in `do' macro, which wraps any Lisp expression for
           ;; use in this list), and we wrap the list in a call to the
           ;; built-in `remind' function, which causes the actions to be
           ;; repeated every 10 minutes until the user manually advances
           ;; to the next interval.
           :advance (remind "10 minutes"
                            ;; Every 10 minutes, while the hammy is waiting
                            ;; to be advanced to the next interval, remind
                            ;; the user by doing these things:
                            (list (announce "Time to stretch your legs!")
                                  (notify "Time to stretch your legs!")
                                  (do (play-sound-file "~/Misc/Sounds/mooove-it.wav")))))
          (interval :name "ðŸ¤¸"
                    :duration (duration "5 minutes")
                    :face 'font-lock-builtin-face
                    :before (list (announce "Mooove it!")
                                  (notify "Mooove it!"))
                    ;; Again, the interval should not advance automatically
                    ;; to the next--the user should indicate when he's
                    ;; actually sat down again.  (If we omitted the
                    ;; `:advance' slot, the interval would automatically
                    ;; advance when it reached its duration.)
                    :advance (list (announce "Time for a sit-down...")
                                   (notify "Time for a sit-down...")
                                   (do (play-sound-file "~/Misc/Sounds/relax.wav"))))))
#+end_src

Then you can use these commands, which will prompt you to choose a defined hammy:

| ~hammy-start~  | Start a hammy.                                                                            |
| ~hammy-next~   | Advance to the next interval of a hammy (when it's defined to not advance automatically). |
| ~hammy-toggle~ | Pause or unpause a hammy.                                                                 |
| ~hammy-reset~  | Reset a hammy (useful when a hammy is defined to behave differently the longer it runs).  |
| ~hammy-stop~   | Stop a hammy.                                                                             |

You may also use these commands:

| ~hammy-mode~     | Show the current hammy in the mode-line. |
| ~hammy-view-log~ | Show the log buffer.                     |

The mode-line looks like this (when no hammy is active, when one is active, and when one is "overdue", waiting for the user to manually advance to the next interval):

[[images/mode-line.png]]

You can see the lighter prefix (~ðŸ¹~), the status (~:~, or ~!~ when overdue), the current hammy's name (~Move~), the current interval's name (~ðŸ’º~), and the time elapsed (prefixed by ~-~ when counting down, and ~+~ when overdue and counting up).

Of course, if you have something against hamsters, the lighter prefix can be customized, as well as various faces for parts of the mode line.  See ~M-x customize-group RET hammy RET~.

Here's a more interesting example, a "flywheel timer" (so called because it helps to build momentum), which interleaves rest periods with gradually lengthening work periods.

#+begin_src elisp
  (hammy-define "Flywheel"
    :documentation "Get your momentum going!"
    :intervals
    (list
     (interval :name "Play"
               :face 'font-lock-type-face
               ;; The play/rest interval will always be 5 minutes long.
               :duration (duration "5 minutes")
               ;; Before starting the interval, announce and notify, to
               ;; show the user that the interval has begun.
               :before (list (announce "Play time!")
                             (notify "Play time!"))
               ;; When the interval's time is up, remind the user every
               ;; 5 minutes to get back to work.
               :advance (remind "5 minutes"
                                (list (announce "Play time is over!")
                                      (notify "Play time is over!")
                                      (do (play-sound-file "~/Misc/Sounds/get-to-workin.wav")))))
     (interval :name "Work"
               :face 'font-lock-builtin-face
               ;; For the work interval, rather than the duration being
               ;; the same each time, it "climbs" from 5 minutes to 45
               ;; minutes, and then descends back to 5 minutes.  For
               ;; this, we use the built-in helper function `climb',
               ;; which returns a lambda function that, when called at
               ;; "hammy time," returns the appropriate duration each
               ;; time this interval begins.
               :duration (climb "5 minutes" "45 minutes"
                                :descend t)
               :before (list (announce "Work time!")
                             (notify "Work time!"))
               :advance (remind "10 minutes"
                                (list (announce "Work time is over!")
                                      (notify "Work time is over!")
                                      (do (play-sound-file "~/Misc/Sounds/relax.wav"))))))
    ;; This predicate returns non-nil when a full session has been
    ;; completed (i.e. when the work interval has reached its duration,
    ;; its duration is 5 minutes, and at least one cycle has been
    ;; completed, in which case the work interval will have "climbed" to
    ;; 45 minutes and back down).  Note that the hammy is the argument
    ;; to the lambda, and slot accessors are used on the hammy and its
    ;; current interval, offering a kind of introspection at runtime (at
    ;; "hammy time," i.e. when the timer's code is run between intervals
    ;; to determine what to do next).
    :complete-p (lambda (hammy)
                  (and (> (hammy-cycles hammy) 1)
                       (hammy-interval hammy)
                       (equal "Work" (hammy-interval-name (hammy-interval hammy)))
                       (equal (duration "5 minutes") (hammy-current-duration hammy))))
    ;; Then, when the hammy has completed all of its cycles, play this
    ;; sound to celebrate.
    :after (do (play-sound-file "~/Misc/Sounds/all-done.wav")))
#+end_src

Note the use of ~:descend t~ in the arguments to the ~climb~ function in the ~Work~ interval's ~:duration~ slot: because of that, it may also be known as a "ladder timer" or a "hill-climb timer", because after the work interval reaches the maximum duration of 45 minutes, it begins decreasing until it reaches the minimum duration.   In this way, the user "spins up", gaining momentum to build endurance, and then "spins down" to finish the session.  This kind of timer may be helpful when working on large projects that are difficult to get started on.

* License

GPLv3
